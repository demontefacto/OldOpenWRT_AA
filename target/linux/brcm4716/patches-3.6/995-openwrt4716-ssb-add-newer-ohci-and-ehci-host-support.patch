From: George Kashperko <george@znau.edu.ua>

Add support for newer AI-based OHCI and EHCI SSB host controllers.
Signed-off-by: George Kashperko <george@znau.edu.ua>
---
 drivers/ssb/driver_mipscore.c |    1 
 drivers/usb/host/ssb-hcd.c    |   74 ++++++++++++++++++++++++++------
 include/linux/ssb/ssb.h       |    1 
 3 files changed, 63 insertions(+), 13 deletions(-)
--- linux-3.6.8.orig/drivers/ssb/driver_mipscore.c	2012-12-08 02:58:56.909356445 +0200
+++ linux-3.6.8/drivers/ssb/driver_mipscore.c	2012-12-08 14:22:28.494552073 +0200
@@ -349,6 +349,7 @@ u32 ssb_cpu_clock(struct ssb_mipscore *m
 
 	return rate;
 }
+EXPORT_SYMBOL(ssb_cpu_clock);
 
 void ssb_mipscore_init(struct ssb_mipscore *mcore)
 {
--- linux-3.6.8.orig/drivers/usb/host/ssb-hcd.c	2012-12-08 02:55:27.141370789 +0200
+++ linux-3.6.8/drivers/usb/host/ssb-hcd.c	2012-12-08 14:22:28.494552073 +0200
@@ -53,6 +53,40 @@ static void __devinit ssb_hcd_5354wa(str
 #endif
 }
 
+static void __devinit ssb_bcm4716_war(struct ssb_device *dev)
+{
+#ifdef CONFIG_BCM47XX
+#define SSB_BCM4716_WAR_DELAY	500
+	struct ssb_bus *bus = dev->bus;
+	u32 tmp;
+
+	tmp = ssb_cpu_clock(&bus->mipscore);
+	if (tmp >= 480000000)
+		tmp = 0x0001846B; /* set CDR to 0x11(fast) */
+	else if (tmp == 453000000)
+		tmp = 0x0001046B; /* set CDR to 0x10(slow) */
+	else
+		tmp = 0;
+
+	/* Change Shim mdio control reg to fix host
+	 * not acking at high frequencies */
+	if (tmp) {
+		ssb_write32(dev, 0x524, 0x01); /* write sel to enable */
+		udelay(SSB_BCM4716_WAR_DELAY);
+	
+		ssb_write32(dev, 0x524, tmp);
+		udelay(SSB_BCM4716_WAR_DELAY);
+	
+		ssb_write32(dev, 0x524, 0x4AB);
+		udelay(SSB_BCM4716_WAR_DELAY);
+	
+		tmp = ssb_read32(dev, 0x528);
+		printk("USB20H mdio control register: 0x%X\n", tmp);
+		ssb_write32(dev, 0x528, 0x80000000);
+	}
+#endif /* CONFIG_BCM47XX */
+}
+
 static void __devinit ssb_hcd_usb20wa(struct ssb_device *dev)
 {
 	if (dev->id.coreid == SSB_DEV_USB20_HOST) {
@@ -65,17 +99,23 @@ static void __devinit ssb_hcd_usb20wa(st
 		 */
 		ssb_write32(dev, 0x200, 0x7ff);
 
-		/* Change Flush control reg */
-		ssb_write32(dev, 0x400, ssb_read32(dev, 0x400) & ~8);
-		ssb_read32(dev, 0x400);
-
-		/* Change Shim control reg */
-		ssb_write32(dev, 0x304, ssb_read32(dev, 0x304) & ~0x100);
-		ssb_read32(dev, 0x304);
+		/* Check to avoid kernel oops on bcm4716-based ASUS RT-N16.
+		 * Maybe will be required for other ai-based socs as well. */
+		if (dev->bus->chip_id == 0x4716) {
+			ssb_bcm4716_war(dev);
+		} else {
+			/* Change Flush control reg */
+			ssb_write32(dev, 0x400, ssb_read32(dev, 0x400) & ~8);
+			ssb_read32(dev, 0x400);
+
+			/* Change Shim control reg */
+			ssb_write32(dev, 0x304, ssb_read32(dev, 0x304) & ~0x100);
+			ssb_read32(dev, 0x304);
 
-		udelay(1);
+			udelay(1);
 
-		ssb_hcd_5354wa(dev);
+			ssb_hcd_5354wa(dev);
+		}
 	}
 }
 
@@ -151,7 +191,7 @@ err_alloc:
 static int __devinit ssb_hcd_probe(struct ssb_device *dev,
 				   const struct ssb_device_id *id)
 {
-	int err, tmp;
+	int err, tmp, adm;
 	int start, len;
 	u16 chipid_top;
 	u16 coreid = dev->id.coreid;
@@ -178,10 +218,15 @@ static int __devinit ssb_hcd_probe(struc
 	 * be written) Client mode driver. Same for remove(). */
 	usb_dev->enable_flags = ssb_hcd_init_chip(dev);
 
-	tmp = ssb_admatch_base(dev, SSB_ADMATCH0);
+	/* For AI type socs OHCI mapped regs space is
+	 * second core register set */
+	adm = dev->bus->chipco.chiptype == SSB_CHIPCO_AI ?
+	      SSB_ADMATCH1 : SSB_ADMATCH0;
+
+	tmp = ssb_admatch_base(dev, adm);
 
 	start = tmp;
-	len = ssb_admatch_size(dev, SSB_ADMATCH0);
+	len = ssb_admatch_size(dev, adm);
 	usb_dev->ohci_dev = ssb_hcd_create_pdev(dev, true, start, len);
 	if (IS_ERR(usb_dev->ohci_dev)) {
 		err = PTR_ERR(usb_dev->ohci_dev);
@@ -189,7 +234,9 @@ static int __devinit ssb_hcd_probe(struc
 	}
 
 	if (coreid == SSB_DEV_USB20_HOST) {
-		start = tmp + 0x800; /* ehci core offset */
+		/* ehci core offset */
+		start = dev->bus->chipco.chiptype == SSB_CHIPCO_AI ?
+			ssb_admatch_base(dev, SSB_ADMATCH0) : tmp + 0x800;
 		usb_dev->ehci_dev = ssb_hcd_create_pdev(dev, false, start, len);
 		if (IS_ERR(usb_dev->ehci_dev)) {
 			err = PTR_ERR(usb_dev->ehci_dev);
@@ -253,6 +300,7 @@ static const struct ssb_device_id ssb_hc
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOSTDEV, SSB_ANY_REV),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOST, SSB_ANY_REV),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB20_HOST, SSB_ANY_REV),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM2, SSB_DEV_USB20_HOST, SSB_ANY_REV),
 	SSB_DEVTABLE_END
 };
 MODULE_DEVICE_TABLE(ssb, ssb_hcd_table);
--- linux-3.6.8.orig/include/linux/ssb/ssb.h	2012-12-08 02:59:52.260352660 +0200
+++ linux-3.6.8/include/linux/ssb/ssb.h	2012-12-08 14:22:28.495552073 +0200
@@ -260,6 +260,7 @@ struct ssb_bus_ops {
 
 /* Vendor-ID values */
 #define SSB_VENDOR_BROADCOM	0x4243
+#define SSB_VENDOR_BROADCOM2	0x04BF
 #define SSB_VENDOR_ARM		0x043B
 
 /* Some kernel subsystems poke with dev->drvdata, so we must use the
